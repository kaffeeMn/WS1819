\newpage
\section{Teil2}

\subsection{Software Architektur}

\subsubsection{Architekturmuster}

Wir haben folgende Architekutrstile kennen gelernt:\\
\begin{itemize}
    \item Objekt orientiert
    \item Client-Server
    \item Pipe and filter
    \item Ereignisorientiert
    \item Schichten
    \item Repository
    \item Process controll
\end{itemize}
Objekt orientierte Architektur wird beispielsweise bei abstrakten Datetypen verwendet.
So wird die interne Datendarstellung von der Außenwelt abgekapselt.
Auf mehrere Agenten zerlegbar.
Ein Nachteil jedoch ist, dass Objekte die Identität anderer Objekte kennen müssen, um zu interagieren.
\\ \\
Client-Server Architektur verteilt die Anwendungslogik auf eine Menge von Clients und Serversubsystemen.
In der Regel werden Clients uns Serversubsysteme auf verschiedenen Maschinen realisiert und kommunizieren über ein
Netzwerk.
Nachteil hierbei ist, dass die Clients die Identität des Servers kennen müssen.
\\ \\
Peer to Peer, wobei Peers durch einen Server oder Broadcast gefunden werden.
Engpässe werden reduziert und die Architektur ist robust gegenüber Peer-Ausfällen.
Nachteile sind jedoch, dass der Server ein Engpass werden kann und Peers nur eine unvollständige Sicht-Synchronization 
ermöglichen.
\\ \\
Pipe and Filter wird u.a. bei Unix Pipes, Compiler Ketten und Signal Prozessoren verwendet.
Filter können parrallel implementiert werden und müssen nichts über die verbundenen Elemente wissen.
\\ \\
Ereignisorientierte Architektur findet beispielsweise bei Debuggern und Graphischen Benutzerschnittstellen Anwendung.
Es wird auf Ereignisse gelauscht, wobei die Ereignisquelle die Ereignissenken nicht kennen muss.
Ein großer Nachteil ist, dass die Komponenten keine Kontrolle über die Berechnungsreihenfolge haben (Endlosschleifen).
\\ \\
Schichtenarchitektur beschreibt die Einteilung von Software in verschieden Schichten 
(e.g. Benutzerschnittstelle, Benutzerschnittstellenverwaltung, Buisinesslogik, OS/DB)
Ein Beispiel für die Schichtenarchitektur wäre das ISO/OSI Modell aus RvS.
\\ \\
Repositories reduzieren die Notwendigkeit komplexe Daten zu duplizieren.
Das Blackboard verwaltet dabei alle Daten zentral im einzelnem, gemeinsamen Repository.
\\ \\
Model View Controller beschreibt ein Zentrales Modell mehrerer Schichten, dem Model, View und Controller.
Der Controller verarbeitet Updates der Nutzerschicht, der Controller updated das Model und notifiziert die View.
Das Modell füllt die View.
\\ \\
REST

Der Representational State Transfer basier auf folgenden Prinzipien:
\begin{itemize}
    \item Client-Server
    \item Zustandslosigkeit
    \item Caching
    \item Einheitliche Schnittstelle
    \item Mehrschichtige Systeme
    \item (Code on Demand)
\end{itemize}

\subsubsection{Qualität von Architektur}

Die Menge von Beziehungen zwischen Subsystemen nennen wir Kopplung, sie ist ein Maß für die Verbundenheit von Elementen.
Im allgemienem ist starke Kopplung schlecht, da mit ihr Klassen nur schwer isoliert verstanden werden können, Klassen
ohne verbundene Klassen nicht wieder verwendet werden können.
Im Gegenzug ist lose Kopplung gut, da sie die Wartbarkeit verbessert und Klassen unanbhängig sind.
\\ \\
Kohäsion ist ein weiterer wichtiger Begriff, geringe Kohäsion bedeutet, dass ein ELement wenig ider unzusammenhängende 
Funktionalität bietet.
Es erschwert Verständnis und Wartbarkeit.
Elemente mit hoher Kohäsion sind also einfacher Verständlich/ weniger Komplex.

\subsubsection{Weitere Muster}

\begin{itemize}
    \item Vertikale Dekomposition: Anwendung in mehrere unabhängige Anwendungen von vornherein zerlegen.
    \item Distributed Computing: Horizontale Schnittstelle z.B. Kommunikation über REST
    \item Sharding: Aufteilung der Eingabe auf dedizierte Prozesse (e.g. Aufteilung nach Anfangsbuchstaben)
    \item Load Balancing: dynamische Zuordnung der Bearbeitung (e.g. nach Auslastung)
    \item Microservice Architektur: Applikationen sind Folge unabhängiger Dienste
            \begin{itemize}
                \item Komponentenzerlegung via Dienste möglich
                \item Organisiert um betriebswirtschaftliche Funktionen
                \item Entwicklung eher Produkte als Projekte
                \item Smarte Endpunkte und dumme Verbindungen
                \item Ausfallsicher und Evolutionsfähig
                \item Dezentrale Anwendungs- und Datenverwaltung
            \end{itemize}
\end{itemize}
Die Varianten Sharding und Load Balancing können auch kombiniert werden, um Skalierbarkeit zu erhöhen.

\subsection{Konfigurationsmanagement}

\subsubsection{Source Code Management}

Eine Versionsverwartlung hat unter anderem folgende Aufgaben
\begin{itemize}
    \item Identifizierung der Version
    \item Festlegung aller zu verwaltenden Bestandteile
    \item Namenskonventionen und Relation zwischen den Komponenten
    \item Verschiedene Versionen einer Komponenete müssen abgespeichert werden
    \item beliebige abgespeicherte Versionen müssen bereitgestellt werden können
    \item Dokumentation von Änderungen
    \item Festlegung und Kontrollieren von Zugriffsrechten
    \item Verwaltung des Komponenten-Repositories
\end{itemize}
Commits:

Ein Commit enthält mindestens ein Datum, den Author, eine neue Versionsnummer und eine optionale Begründung.
Der Commit beschreibt also die Menge von Änderungen.
\\ \\
Merge vs. Rebase:

Bei einem Rebase wird der aktuelle Entwicklungsstand des Masterbranches akzeptiert und davon aus weiter gearbeitet.
Jedoch kann bei Parraleler entwicklung ein Merge Konflikt auftreten.
Ferner geht bei einem Rebase sämtliche Information eines Branches verlore/ ein Branch wird zerstört.
\\
Bei einer Merge Operation wird ein Branch in Stand gehalten und die kritischen Sektionionen reviewed/ gesolved bevor ein
Update/ Push zum Masterbranch erfolgt.
\\ \\
Beim Arbeiten mit GIT wird oftmals GIT-Workflow verwendet.
Dabei existieren Branches für master (Production), hotfixes, release, development und einzelne Features.
\\ \\
Der Rosinenpick ist eine Operation, bei der ein einzelner Commit in einen anderen Branch übernommen wird, ohne dabei die
anderen Commits mit zu übernehmen.
%TODO Backporting und KM 48 +

\subsubsection{Build-Automatisierung und Dependency Management}

Nicht relevant.

\subsubsection{Release-Strategien}

Continuous integration

Ein ständiges zusammenführen von Komponenten zu einer ANwendung, dabei ist das Ziel die Steigerung der Softwarequalität.
Oftmals in Kombination von Tests und Qualitätsmetriken.
\\ \\
Continuous Delivery

Maunuelle Software Deployments und Konfiguration der Produktivumgebung.
Software wird erst nach ihrer Fertigstellung in einer der Produktivumgebung ähnlichen Testumgebung getestet.
\\ \\
Deployment Pipeline

%TODO

\subsection{Meta-Modellierung und Domänenspezifische Sprachen}

\subsubsection{Meta-Modellierung}

Nach Stachowiak hat ein Meta Modell 3 Merkmale: Abbildungs-, Verkürzungs- und pragmatisches Merkmal.
Das Modell soll die Beschreibung der Realität vereinfachen.
Die Welt wird also auf eine diskrete Struktur abgebildet.
Dabei werden Struktur, Beziehungen und Verhalten modelliert.
\\ \\
Hinsichtlich UML gelten folgende Anwendungsbereiche:
\begin{itemize}
    \item Anwendungsfalldiagramm: Anforderung an das System
    \item Klassendiagramm: Datenstruktur des Systems
    \item Objektdiagramm: ein Instanz des Models/ Systems
    \item Aktivitätsdiagramm: Steuerung des Ablaufs zwischen Komponenten
\end{itemize}
