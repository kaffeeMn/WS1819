%\documentclass{article}
\documentclass[a4paper,12pt,times,german]{cls/summary}
\usepackage{setspace}
\onehalfspacing

\usepackage{ngerman}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{algorithmic}
\usepackage[]{algorithm2e}
\usepackage{float}
\restylefloat{table}

\title{Der Linearzeit MST-Algorithmus\\
       \LARGE Abstract}
\author{Maximilian Springenberg\\
        \small Proseminar Randomisierte Algorithmen}
\date{}
\setcounter{section}{-1}

\begin{document}
\maketitle
% ******************************** Main Matter *********************************
Der Linearzeit MST-Algorithmus ist ein randomisierter Ansatz, der das MST und MSF
    Problem in erwarteter linearer Laufzeit l"ost.
    Es gibt bereits ein deterministisches Verfahren von Chazelle, dass einen MST in
    $O(m * log \beta(m,n)), \beta(m,n) = \{i | log^{(i)} n \leq m / n\}$
    , wobei $\beta$ die inverse Ackermann Funktion ist, berechnet.
    Unser Algorithmus wird jedoch einfacher zu implementieren sein, bietet eine
    im Erwartungswert bessere Laufzeit und der randomisierte Teil des 
    Algorithmus wird mit hinsichtlich $G$ mit im Erwartungswert $n/p$ nach oben
    beschr"ankt
    $F$-leichten Kanten eine akzeptabele Approximation des MST/MSF ergeben.\\
Eine Kante aus $G$ isr $F$-leicht, wenn sie hinsichtlich eines Waldes $F$ 
    weniger oder gleich
    gewichtet ist, wie die Kante mit maximalem Gewicht auf dem Pfad in $F$,
    der die Knoten der Kante verbindet. 
    Ist das nicht der Fall, so ist die Kante $F$-schwer.
    Mittels $F$-leichter Kanten k"onnen wir daher neben der Summe von Kantengewichten
    ein G"utema"s f"ur einen Wald hinsichtlich $G$ definieren.
    Ferner wird das erkennen von $F$-schweren Kanten n"utzlich sein, wenn wir
    Kanten entfernen m"ochten die nicht im MST/MSF vorkommen.\\
Der aus dem Algorithmus resultierende MST/MSF wird nicht rein randomisiert 
    konstruiert. 
    So werden wir uns auch ein deterministisches Verfahren, n"amlich die
    Bor\r uvka-Phase zur Hilfe nehmen.
    Dies ist notwendig, da wir unseren Algorithmus rekursiv
    aufbauen m"ochten und dazu insbesondere die Kanten- und Knotenmenge des
    betrachteten Graphen in jedem rekursiven Aufruf reduzieren m"ussen.
    Eine Bor\r uvka-Phase nutzt aus, dass f"ur jeden Knoten die minimal gewichtete
    inzidente Kante im MST/MSF vorkommen muss. 
    Es werden also in einer Bor\r uvka-Phase minimale Kanten markiert und die 
    daraus entstehenden verbundenen Komponenten auf je einen Knoten reduziert.
    Im Worst-Case erhalten wir ein perfektes Matching und reduzieren die 
    Knotenmenge auf $|V|/2$.\\
Die randomisierte Konstruktion erfolgt "uber randomisierte Stichproben eines
    des Graphen.
    Dabei wird in unserem Fall jede Kante mit der Wahrscheinlichkeit $p=0,5$
    in der Stichprobe $G(p)$ inkludiert. 
    Es ist leicht ersichtlich, dass hierbei die Kantenmenge im Erwartungswert
    halbiert wird.
    Wie wir im Teil zur G"ute einer randomisierten Stichprobe sehen werden 
    hat $G$ dabei hinsichtlich des MSF von $G(p)$ im Erwartungswert $n/p$
    $F$-leichte Kanten.\\
Der Algorithmus wird drei Bor\r uvka-Phasen ausf"uhren.
    Die rekursion Terminiert, wenn nach einer Bor\r uvka Phasen der Graph 
    unver"andert blieb, oder $G$ leer ist.
    Danach werden wir eine Stichprobe knostruieren und beginnen die erste
    Rekursion.
    "Uber das Resultat der Rekursion werden $F$-schwere Kanten ermittelt, 
    diese aus $G$ entfernt und ein letzter rekursiver Aufruf get"atigt.\\
Interessant ist hierbei, dass wir zwei sucessive rekursive Aufrufe haben, jedoch
    eine lineare Laufzeit erwarten.
    Dies ist darin begr"undet, dass wir den ersten rekursiven Aufruf mit 
    $|V|/8$ Knoten, $|E|/2$ Kante und den zweiten rekursiven Aufruf mit $|V|/8$ Knoten,
    $\frac{|V|/8}{p=0,5} = |V|/4$ Kanten bet"atigen.
    
\end{document}
